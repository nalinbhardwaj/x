// View functions and log parsing from erc4337.json
//
// Code generated by "genabi"; DO NOT EDIT.
package erc4337

import (
	"bytes"
	"github.com/indexsupply/x/abi"
	"github.com/indexsupply/x/abi/schema"
	"github.com/indexsupply/x/e2pg"
	"github.com/indexsupply/x/jrpc"
	"math/big"
)

type AccountDeployedEvent struct {
	item       *abi.Item
	UserOpHash [32]byte
	Sender     [20]byte
	Factory    [20]byte
	Paymaster  [20]byte
}

func (x AccountDeployedEvent) Done() {
	x.item.Done()
}

func DecodeAccountDeployedEvent(item *abi.Item) AccountDeployedEvent {
	x := AccountDeployedEvent{}
	x.item = item
	x.Factory = item.At(0).Address()
	x.Paymaster = item.At(1).Address()
	return x
}

func (x AccountDeployedEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 4)
	items[0] = abi.Bytes32(x.UserOpHash)
	items[1] = abi.Address(x.Sender)
	items[2] = abi.Address(x.Factory)
	items[3] = abi.Address(x.Paymaster)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	AccountDeployedSignatureHash = []byte{0xeb, 0x52, 0x23, 0x69, 0xc7, 0xea, 0x4b, 0x36, 0x74, 0x24, 0x5f, 0x71, 0x88, 0xa, 0x33, 0x74, 0x86, 0x97, 0x25, 0x5d, 0x57, 0xcd, 0x82, 0xc8, 0x2, 0xb, 0xd0, 0x8, 0x54, 0xce, 0xff, 0x6a}
	AccountDeployedSignature     = []byte{0xd5, 0x1a, 0x9c, 0x61, 0x26, 0x7a, 0xa6, 0x19, 0x69, 0x61, 0x88, 0x3e, 0xcf, 0x5f, 0xf2, 0xda, 0x66, 0x19, 0xc3, 0x7d, 0xac, 0xf, 0xa9, 0x21, 0x22, 0x51, 0x3f, 0xb3, 0x2c, 0x3, 0x2d, 0x2d}
	AccountDeployedSchema        = schema.Parse("(address,address)")
	AccountDeployedNumIndexed    = int(2)
)

// Event Signature:
//	AccountDeployed(bytes32,address,address,address)
// Checks the first log topic against the signature hash:
//	d51a9c61267aa6196961883ecf5ff2da6619c37dac0fa92122513fb32c032d2d
//
// Copies indexed event inputs from the remaining topics
// into [AccountDeployed]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [AccountDeployed]:
//	(address,address)
func MatchAccountDeployed(l *e2pg.Log) (AccountDeployedEvent, error) {
	if l.Topics.Len() <= 0 {
		return AccountDeployedEvent{}, abi.NoTopics
	}
	if !bytes.Equal(AccountDeployedSignature, l.Topics.At(0)) {
		return AccountDeployedEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != AccountDeployedNumIndexed {
		return AccountDeployedEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, AccountDeployedSchema)
	if err != nil {
		return AccountDeployedEvent{}, err
	}
	res := DecodeAccountDeployedEvent(item)
	res.UserOpHash = abi.Bytes(l.Topics.At(1)).Bytes32()
	res.Sender = abi.Bytes(l.Topics.At(2)).Address()
	return res, nil
}

type BeforeExecutionEvent struct {
	item *abi.Item
}

func (x BeforeExecutionEvent) Done() {
	x.item.Done()
}

func (x BeforeExecutionEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 0)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	BeforeExecutionSignatureHash = []byte{0x7a, 0xb6, 0x51, 0xb0, 0xfe, 0xa0, 0xbe, 0xb9, 0xd, 0x9a, 0x52, 0x22, 0x0, 0xa2, 0x46, 0xd1, 0xc0, 0x21, 0xf, 0x6c, 0x50, 0x3, 0x40, 0x15, 0x4, 0xdd, 0x63, 0x2a, 0xb8, 0xaa, 0x4c, 0x4f}
	BeforeExecutionSignature     = []byte{0xbb, 0x47, 0xee, 0x3e, 0x18, 0x3a, 0x55, 0x8b, 0x1a, 0x2f, 0xf0, 0x87, 0x4b, 0x7, 0x9f, 0x3f, 0xc5, 0x47, 0x8b, 0x74, 0x54, 0xea, 0xcf, 0x2b, 0xfc, 0x5a, 0xf2, 0xff, 0x58, 0x78, 0xf9, 0x72}
	BeforeExecutionSchema        = schema.Parse("()")
	BeforeExecutionNumIndexed    = int(0)
)

// Event Signature:
//	BeforeExecution()
// Checks the first log topic against the signature hash:
//	bb47ee3e183a558b1a2ff0874b079f3fc5478b7454eacf2bfc5af2ff5878f972
//
// Copies indexed event inputs from the remaining topics
// into [BeforeExecution]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [BeforeExecution]:
//	()
func MatchBeforeExecution(l *e2pg.Log) (BeforeExecutionEvent, error) {
	if l.Topics.Len() <= 0 {
		return BeforeExecutionEvent{}, abi.NoTopics
	}
	if !bytes.Equal(BeforeExecutionSignature, l.Topics.At(0)) {
		return BeforeExecutionEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != BeforeExecutionNumIndexed {
		return BeforeExecutionEvent{}, abi.IndexMismatch
	}
	res := BeforeExecutionEvent{}
	return res, nil
}

type DepositedEvent struct {
	item         *abi.Item
	Account      [20]byte
	TotalDeposit *big.Int
}

func (x DepositedEvent) Done() {
	x.item.Done()
}

func DecodeDepositedEvent(item *abi.Item) DepositedEvent {
	x := DepositedEvent{}
	x.item = item
	x.TotalDeposit = item.At(0).BigInt()
	return x
}

func (x DepositedEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	items[0] = abi.Address(x.Account)
	items[1] = abi.BigInt(x.TotalDeposit)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	DepositedSignatureHash = []byte{0xc, 0x11, 0xd8, 0xf6, 0x15, 0xd, 0x1e, 0xc, 0x8, 0x64, 0x74, 0xa6, 0x50, 0x33, 0x16, 0x30, 0x24, 0xa0, 0x40, 0x78, 0x51, 0xe, 0xcb, 0x2c, 0x8b, 0xd2, 0x1, 0x1d, 0xf6, 0xd, 0xde, 0xae}
	DepositedSignature     = []byte{0x2d, 0xa4, 0x66, 0xa7, 0xb2, 0x43, 0x4, 0xf4, 0x7e, 0x87, 0xfa, 0x2e, 0x1e, 0x5a, 0x81, 0xb9, 0x83, 0x1c, 0xe5, 0x4f, 0xec, 0x19, 0x5, 0x5c, 0xe2, 0x77, 0xca, 0x2f, 0x39, 0xba, 0x42, 0xc4}
	DepositedSchema        = schema.Parse("(uint256)")
	DepositedNumIndexed    = int(1)
)

// Event Signature:
//	Deposited(address,uint256)
// Checks the first log topic against the signature hash:
//	2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c4
//
// Copies indexed event inputs from the remaining topics
// into [Deposited]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [Deposited]:
//	(uint256)
func MatchDeposited(l *e2pg.Log) (DepositedEvent, error) {
	if l.Topics.Len() <= 0 {
		return DepositedEvent{}, abi.NoTopics
	}
	if !bytes.Equal(DepositedSignature, l.Topics.At(0)) {
		return DepositedEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != DepositedNumIndexed {
		return DepositedEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, DepositedSchema)
	if err != nil {
		return DepositedEvent{}, err
	}
	res := DecodeDepositedEvent(item)
	res.Account = abi.Bytes(l.Topics.At(1)).Address()
	return res, nil
}

type SignatureAggregatorChangedEvent struct {
	item       *abi.Item
	Aggregator [20]byte
}

func (x SignatureAggregatorChangedEvent) Done() {
	x.item.Done()
}

func (x SignatureAggregatorChangedEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Address(x.Aggregator)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	SignatureAggregatorChangedSignatureHash = []byte{0x30, 0x11, 0x96, 0x5c, 0x57, 0xf0, 0x7b, 0xff, 0x51, 0x20, 0xe3, 0xdb, 0xbd, 0xc0, 0x44, 0x95, 0x2, 0x4f, 0xf9, 0x60, 0xa8, 0xca, 0xaf, 0x71, 0x17, 0x1a, 0x3c, 0xe1, 0x10, 0x75, 0xd3, 0x83}
	SignatureAggregatorChangedSignature     = []byte{0x57, 0x5f, 0xf3, 0xac, 0xad, 0xd5, 0xab, 0x34, 0x8f, 0xe1, 0x85, 0x5e, 0x21, 0x7e, 0xf, 0x36, 0x78, 0xf8, 0xd7, 0x67, 0xd7, 0x49, 0x4c, 0x9f, 0x9f, 0xef, 0xbe, 0xe2, 0xe1, 0x7c, 0xca, 0x4d}
	SignatureAggregatorChangedSchema        = schema.Parse("()")
	SignatureAggregatorChangedNumIndexed    = int(1)
)

// Event Signature:
//	SignatureAggregatorChanged(address)
// Checks the first log topic against the signature hash:
//	575ff3acadd5ab348fe1855e217e0f3678f8d767d7494c9f9fefbee2e17cca4d
//
// Copies indexed event inputs from the remaining topics
// into [SignatureAggregatorChanged]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [SignatureAggregatorChanged]:
//	()
func MatchSignatureAggregatorChanged(l *e2pg.Log) (SignatureAggregatorChangedEvent, error) {
	if l.Topics.Len() <= 0 {
		return SignatureAggregatorChangedEvent{}, abi.NoTopics
	}
	if !bytes.Equal(SignatureAggregatorChangedSignature, l.Topics.At(0)) {
		return SignatureAggregatorChangedEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != SignatureAggregatorChangedNumIndexed {
		return SignatureAggregatorChangedEvent{}, abi.IndexMismatch
	}
	res := SignatureAggregatorChangedEvent{}
	res.Aggregator = abi.Bytes(l.Topics.At(1)).Address()
	return res, nil
}

type StakeLockedEvent struct {
	item            *abi.Item
	Account         [20]byte
	TotalStaked     *big.Int
	UnstakeDelaySec *big.Int
}

func (x StakeLockedEvent) Done() {
	x.item.Done()
}

func DecodeStakeLockedEvent(item *abi.Item) StakeLockedEvent {
	x := StakeLockedEvent{}
	x.item = item
	x.TotalStaked = item.At(0).BigInt()
	x.UnstakeDelaySec = item.At(1).BigInt()
	return x
}

func (x StakeLockedEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 3)
	items[0] = abi.Address(x.Account)
	items[1] = abi.BigInt(x.TotalStaked)
	items[2] = abi.BigInt(x.UnstakeDelaySec)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	StakeLockedSignatureHash = []byte{0x30, 0x69, 0xf0, 0xf8, 0x1, 0x6e, 0x6e, 0xe9, 0xe3, 0xcb, 0x9e, 0xf, 0x40, 0xfd, 0x71, 0x59, 0xb6, 0x89, 0x39, 0x16, 0xe1, 0x80, 0x8f, 0x5e, 0x68, 0xa1, 0xb2, 0x39, 0x8e, 0xf1, 0x8f, 0x4}
	StakeLockedSignature     = []byte{0xa5, 0xae, 0x83, 0x3d, 0xb, 0xb1, 0xdc, 0xd6, 0x32, 0xd9, 0x8a, 0x8b, 0x70, 0x97, 0x3e, 0x85, 0x16, 0x81, 0x28, 0x98, 0xe1, 0x9b, 0xf2, 0x7b, 0x70, 0x7, 0x1e, 0xbc, 0x8d, 0xc5, 0x2c, 0x1}
	StakeLockedSchema        = schema.Parse("(uint256,uint256)")
	StakeLockedNumIndexed    = int(1)
)

// Event Signature:
//	StakeLocked(address,uint256,uint256)
// Checks the first log topic against the signature hash:
//	a5ae833d0bb1dcd632d98a8b70973e8516812898e19bf27b70071ebc8dc52c01
//
// Copies indexed event inputs from the remaining topics
// into [StakeLocked]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [StakeLocked]:
//	(uint256,uint256)
func MatchStakeLocked(l *e2pg.Log) (StakeLockedEvent, error) {
	if l.Topics.Len() <= 0 {
		return StakeLockedEvent{}, abi.NoTopics
	}
	if !bytes.Equal(StakeLockedSignature, l.Topics.At(0)) {
		return StakeLockedEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != StakeLockedNumIndexed {
		return StakeLockedEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, StakeLockedSchema)
	if err != nil {
		return StakeLockedEvent{}, err
	}
	res := DecodeStakeLockedEvent(item)
	res.Account = abi.Bytes(l.Topics.At(1)).Address()
	return res, nil
}

type StakeUnlockedEvent struct {
	item         *abi.Item
	Account      [20]byte
	WithdrawTime *big.Int
}

func (x StakeUnlockedEvent) Done() {
	x.item.Done()
}

func DecodeStakeUnlockedEvent(item *abi.Item) StakeUnlockedEvent {
	x := StakeUnlockedEvent{}
	x.item = item
	x.WithdrawTime = item.At(0).BigInt()
	return x
}

func (x StakeUnlockedEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	items[0] = abi.Address(x.Account)
	items[1] = abi.BigInt(x.WithdrawTime)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	StakeUnlockedSignatureHash = []byte{0xb4, 0xa4, 0xc7, 0x4d, 0x63, 0x7f, 0xd4, 0xec, 0x73, 0xd8, 0x38, 0x56, 0x7d, 0x2c, 0x50, 0x58, 0x14, 0x40, 0x92, 0x80, 0x29, 0x3f, 0xd1, 0xd, 0xd0, 0x76, 0x2b, 0xb9, 0xf7, 0xef, 0x57, 0x67}
	StakeUnlockedSignature     = []byte{0xfa, 0x9b, 0x3c, 0x14, 0xcc, 0x82, 0x5c, 0x41, 0x2c, 0x9e, 0xd8, 0x1b, 0x3b, 0xa3, 0x65, 0xa5, 0xb4, 0x59, 0x43, 0x94, 0x3, 0xf1, 0x88, 0x29, 0xe5, 0x72, 0xed, 0x53, 0xa4, 0x18, 0xf, 0xa}
	StakeUnlockedSchema        = schema.Parse("(uint256)")
	StakeUnlockedNumIndexed    = int(1)
)

// Event Signature:
//	StakeUnlocked(address,uint256)
// Checks the first log topic against the signature hash:
//	fa9b3c14cc825c412c9ed81b3ba365a5b459439403f18829e572ed53a4180f0a
//
// Copies indexed event inputs from the remaining topics
// into [StakeUnlocked]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [StakeUnlocked]:
//	(uint256)
func MatchStakeUnlocked(l *e2pg.Log) (StakeUnlockedEvent, error) {
	if l.Topics.Len() <= 0 {
		return StakeUnlockedEvent{}, abi.NoTopics
	}
	if !bytes.Equal(StakeUnlockedSignature, l.Topics.At(0)) {
		return StakeUnlockedEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != StakeUnlockedNumIndexed {
		return StakeUnlockedEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, StakeUnlockedSchema)
	if err != nil {
		return StakeUnlockedEvent{}, err
	}
	res := DecodeStakeUnlockedEvent(item)
	res.Account = abi.Bytes(l.Topics.At(1)).Address()
	return res, nil
}

type StakeWithdrawnEvent struct {
	item            *abi.Item
	Account         [20]byte
	WithdrawAddress [20]byte
	Amount          *big.Int
}

func (x StakeWithdrawnEvent) Done() {
	x.item.Done()
}

func DecodeStakeWithdrawnEvent(item *abi.Item) StakeWithdrawnEvent {
	x := StakeWithdrawnEvent{}
	x.item = item
	x.WithdrawAddress = item.At(0).Address()
	x.Amount = item.At(1).BigInt()
	return x
}

func (x StakeWithdrawnEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 3)
	items[0] = abi.Address(x.Account)
	items[1] = abi.Address(x.WithdrawAddress)
	items[2] = abi.BigInt(x.Amount)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	StakeWithdrawnSignatureHash = []byte{0xf5, 0xc3, 0x3f, 0x22, 0xff, 0x1b, 0x9a, 0x49, 0x5e, 0xa2, 0x2b, 0xc9, 0xff, 0x27, 0x57, 0x47, 0x89, 0xb6, 0x75, 0x86, 0x4d, 0x5d, 0x71, 0xe7, 0x3d, 0x85, 0x59, 0xe0, 0x29, 0xd4, 0x9e, 0xa8}
	StakeWithdrawnSignature     = []byte{0xb7, 0xc9, 0x18, 0xe0, 0xe2, 0x49, 0xf9, 0x99, 0xe9, 0x65, 0xca, 0xfe, 0xb6, 0xc6, 0x64, 0x27, 0x1b, 0x3f, 0x43, 0x17, 0xd2, 0x96, 0x46, 0x15, 0x0, 0xe7, 0x1d, 0xa3, 0x9f, 0xc, 0xbd, 0xa3}
	StakeWithdrawnSchema        = schema.Parse("(address,uint256)")
	StakeWithdrawnNumIndexed    = int(1)
)

// Event Signature:
//	StakeWithdrawn(address,address,uint256)
// Checks the first log topic against the signature hash:
//	b7c918e0e249f999e965cafeb6c664271b3f4317d296461500e71da39f0cbda3
//
// Copies indexed event inputs from the remaining topics
// into [StakeWithdrawn]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [StakeWithdrawn]:
//	(address,uint256)
func MatchStakeWithdrawn(l *e2pg.Log) (StakeWithdrawnEvent, error) {
	if l.Topics.Len() <= 0 {
		return StakeWithdrawnEvent{}, abi.NoTopics
	}
	if !bytes.Equal(StakeWithdrawnSignature, l.Topics.At(0)) {
		return StakeWithdrawnEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != StakeWithdrawnNumIndexed {
		return StakeWithdrawnEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, StakeWithdrawnSchema)
	if err != nil {
		return StakeWithdrawnEvent{}, err
	}
	res := DecodeStakeWithdrawnEvent(item)
	res.Account = abi.Bytes(l.Topics.At(1)).Address()
	return res, nil
}

type UserOperationEventEvent struct {
	item          *abi.Item
	UserOpHash    [32]byte
	Sender        [20]byte
	Paymaster     [20]byte
	Nonce         *big.Int
	Success       bool
	ActualGasCost *big.Int
	ActualGasUsed *big.Int
}

func (x UserOperationEventEvent) Done() {
	x.item.Done()
}

func DecodeUserOperationEventEvent(item *abi.Item) UserOperationEventEvent {
	x := UserOperationEventEvent{}
	x.item = item
	x.Nonce = item.At(0).BigInt()
	x.Success = item.At(1).Bool()
	x.ActualGasCost = item.At(2).BigInt()
	x.ActualGasUsed = item.At(3).BigInt()
	return x
}

func (x UserOperationEventEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 7)
	items[0] = abi.Bytes32(x.UserOpHash)
	items[1] = abi.Address(x.Sender)
	items[2] = abi.Address(x.Paymaster)
	items[3] = abi.BigInt(x.Nonce)
	items[4] = abi.Bool(x.Success)
	items[5] = abi.BigInt(x.ActualGasCost)
	items[6] = abi.BigInt(x.ActualGasUsed)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	UserOperationEventSignatureHash = []byte{0xfa, 0x29, 0x4e, 0x29, 0x1e, 0xf3, 0xc3, 0x13, 0x19, 0xed, 0x2b, 0xd9, 0x6b, 0x14, 0xf5, 0x55, 0xf, 0x55, 0x4e, 0xd2, 0x20, 0x59, 0xe8, 0xbc, 0x7c, 0xc4, 0x73, 0x50, 0x57, 0x96, 0x31, 0x4e}
	UserOperationEventSignature     = []byte{0x49, 0x62, 0x8f, 0xd1, 0x47, 0x10, 0x6, 0xc1, 0x48, 0x2d, 0xa8, 0x80, 0x28, 0xe9, 0xce, 0x4d, 0xbb, 0x8, 0xb, 0x81, 0x5c, 0x9b, 0x3, 0x44, 0xd3, 0x9e, 0x5a, 0x8e, 0x6e, 0xc1, 0x41, 0x9f}
	UserOperationEventSchema        = schema.Parse("(uint256,bool,uint256,uint256)")
	UserOperationEventNumIndexed    = int(3)
)

// Event Signature:
//	UserOperationEvent(bytes32,address,address,uint256,bool,uint256,uint256)
// Checks the first log topic against the signature hash:
//	49628fd1471006c1482da88028e9ce4dbb080b815c9b0344d39e5a8e6ec1419f
//
// Copies indexed event inputs from the remaining topics
// into [UserOperationEvent]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [UserOperationEvent]:
//	(uint256,bool,uint256,uint256)
func MatchUserOperationEvent(l *e2pg.Log) (UserOperationEventEvent, error) {
	if l.Topics.Len() <= 0 {
		return UserOperationEventEvent{}, abi.NoTopics
	}
	if !bytes.Equal(UserOperationEventSignature, l.Topics.At(0)) {
		return UserOperationEventEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != UserOperationEventNumIndexed {
		return UserOperationEventEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, UserOperationEventSchema)
	if err != nil {
		return UserOperationEventEvent{}, err
	}
	res := DecodeUserOperationEventEvent(item)
	res.UserOpHash = abi.Bytes(l.Topics.At(1)).Bytes32()
	res.Sender = abi.Bytes(l.Topics.At(2)).Address()
	res.Paymaster = abi.Bytes(l.Topics.At(3)).Address()
	return res, nil
}

type UserOperationRevertReasonEvent struct {
	item         *abi.Item
	UserOpHash   [32]byte
	Sender       [20]byte
	Nonce        *big.Int
	RevertReason []byte
}

func (x UserOperationRevertReasonEvent) Done() {
	x.item.Done()
}

func DecodeUserOperationRevertReasonEvent(item *abi.Item) UserOperationRevertReasonEvent {
	x := UserOperationRevertReasonEvent{}
	x.item = item
	x.Nonce = item.At(0).BigInt()
	x.RevertReason = item.At(1).Bytes()
	return x
}

func (x UserOperationRevertReasonEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 4)
	items[0] = abi.Bytes32(x.UserOpHash)
	items[1] = abi.Address(x.Sender)
	items[2] = abi.BigInt(x.Nonce)
	items[3] = abi.Bytes(x.RevertReason)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	UserOperationRevertReasonSignatureHash = []byte{0x54, 0xdb, 0x78, 0xd8, 0x45, 0x16, 0xdf, 0xba, 0x7d, 0x84, 0x11, 0xc6, 0xef, 0xb3, 0x80, 0xfb, 0xc8, 0x3b, 0x1e, 0xa9, 0xbb, 0xe1, 0x8, 0x79, 0xeb, 0x8b, 0x33, 0xb8, 0x40, 0x76, 0x89, 0x66}
	UserOperationRevertReasonSignature     = []byte{0x1c, 0x4f, 0xad, 0xa7, 0x37, 0x4c, 0xa, 0x9e, 0xe8, 0x84, 0x1f, 0xc3, 0x8a, 0xfe, 0x82, 0x93, 0x2d, 0xc0, 0xf8, 0xe6, 0x90, 0x12, 0xe9, 0x27, 0xf0, 0x61, 0xa8, 0xba, 0xe6, 0x11, 0xa2, 0x1}
	UserOperationRevertReasonSchema        = schema.Parse("(uint256,bytes)")
	UserOperationRevertReasonNumIndexed    = int(2)
)

// Event Signature:
//	UserOperationRevertReason(bytes32,address,uint256,bytes)
// Checks the first log topic against the signature hash:
//	1c4fada7374c0a9ee8841fc38afe82932dc0f8e69012e927f061a8bae611a201
//
// Copies indexed event inputs from the remaining topics
// into [UserOperationRevertReason]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [UserOperationRevertReason]:
//	(uint256,bytes)
func MatchUserOperationRevertReason(l *e2pg.Log) (UserOperationRevertReasonEvent, error) {
	if l.Topics.Len() <= 0 {
		return UserOperationRevertReasonEvent{}, abi.NoTopics
	}
	if !bytes.Equal(UserOperationRevertReasonSignature, l.Topics.At(0)) {
		return UserOperationRevertReasonEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != UserOperationRevertReasonNumIndexed {
		return UserOperationRevertReasonEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, UserOperationRevertReasonSchema)
	if err != nil {
		return UserOperationRevertReasonEvent{}, err
	}
	res := DecodeUserOperationRevertReasonEvent(item)
	res.UserOpHash = abi.Bytes(l.Topics.At(1)).Bytes32()
	res.Sender = abi.Bytes(l.Topics.At(2)).Address()
	return res, nil
}

type WithdrawnEvent struct {
	item            *abi.Item
	Account         [20]byte
	WithdrawAddress [20]byte
	Amount          *big.Int
}

func (x WithdrawnEvent) Done() {
	x.item.Done()
}

func DecodeWithdrawnEvent(item *abi.Item) WithdrawnEvent {
	x := WithdrawnEvent{}
	x.item = item
	x.WithdrawAddress = item.At(0).Address()
	x.Amount = item.At(1).BigInt()
	return x
}

func (x WithdrawnEvent) Encode() *abi.Item {
	items := make([]*abi.Item, 3)
	items[0] = abi.Address(x.Account)
	items[1] = abi.Address(x.WithdrawAddress)
	items[2] = abi.BigInt(x.Amount)
	return abi.Tuple(items...)
}

var (
	// Pre-compute for efficient bloom filter checks
	WithdrawnSignatureHash = []byte{0x88, 0xa3, 0x92, 0xb9, 0x35, 0x1c, 0x8d, 0xdf, 0x75, 0x6c, 0x3b, 0xc4, 0xc5, 0x4d, 0xe5, 0xc9, 0x5, 0x7c, 0x11, 0x6, 0x9, 0x70, 0xbf, 0x91, 0xec, 0x59, 0x9a, 0xdf, 0x25, 0x72, 0xdd, 0x10}
	WithdrawnSignature     = []byte{0xd1, 0xc1, 0x9f, 0xbc, 0xd4, 0x55, 0x1a, 0x5e, 0xdf, 0xb6, 0x6d, 0x43, 0xd2, 0xe3, 0x37, 0xc0, 0x48, 0x37, 0xaf, 0xda, 0x34, 0x82, 0xb4, 0x2b, 0xdf, 0x56, 0x9a, 0x8f, 0xcc, 0xda, 0xe5, 0xfb}
	WithdrawnSchema        = schema.Parse("(address,uint256)")
	WithdrawnNumIndexed    = int(1)
)

// Event Signature:
//	Withdrawn(address,address,uint256)
// Checks the first log topic against the signature hash:
//	d1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb
//
// Copies indexed event inputs from the remaining topics
// into [Withdrawn]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [Withdrawn]:
//	(address,uint256)
func MatchWithdrawn(l *e2pg.Log) (WithdrawnEvent, error) {
	if l.Topics.Len() <= 0 {
		return WithdrawnEvent{}, abi.NoTopics
	}
	if !bytes.Equal(WithdrawnSignature, l.Topics.At(0)) {
		return WithdrawnEvent{}, abi.SigMismatch
	}
	if l.Topics.Len()-1 != WithdrawnNumIndexed {
		return WithdrawnEvent{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, WithdrawnSchema)
	if err != nil {
		return WithdrawnEvent{}, err
	}
	res := DecodeWithdrawnEvent(item)
	res.Account = abi.Bytes(l.Topics.At(1)).Address()
	return res, nil
}

type AddStakeRequest struct {
	item             *abi.Item
	_UnstakeDelaySec uint32
}

func (x AddStakeRequest) Done() {
	x.item.Done()
}

func DecodeAddStakeRequest(item *abi.Item) AddStakeRequest {
	x := AddStakeRequest{}
	x.item = item
	x._UnstakeDelaySec = item.At(0).Uint32()
	return x
}

func (x AddStakeRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Uint32(x._UnstakeDelaySec)
	return abi.Tuple(items...)
}

var (
	AddStakeRequestSignature = []byte{0x3, 0x96, 0xcb, 0x60, 0x79, 0x1a, 0x6d, 0x8b, 0xfe, 0x2c, 0x72, 0x32, 0x63, 0x74, 0x78, 0xd7, 0xee, 0xdd, 0xe5, 0xde, 0xf2, 0x92, 0xa2, 0x50, 0x84, 0xf5, 0x70, 0xa3, 0xf3, 0xd7, 0x75, 0xd4}
	AddStakeResponseSchema   = schema.Parse("()")
)

type BalanceOfRequest struct {
	item    *abi.Item
	Account [20]byte
}

func (x BalanceOfRequest) Done() {
	x.item.Done()
}

func DecodeBalanceOfRequest(item *abi.Item) BalanceOfRequest {
	x := BalanceOfRequest{}
	x.item = item
	x.Account = item.At(0).Address()
	return x
}

func (x BalanceOfRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Address(x.Account)
	return abi.Tuple(items...)
}

type BalanceOfResponse struct {
	item      *abi.Item
	BalanceOf *big.Int
}

func (x BalanceOfResponse) Done() {
	x.item.Done()
}

func DecodeBalanceOfResponse(item *abi.Item) BalanceOfResponse {
	x := BalanceOfResponse{}
	x.item = item
	x.BalanceOf = item.At(0).BigInt()
	return x
}

func (x BalanceOfResponse) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.BigInt(x.BalanceOf)
	return abi.Tuple(items...)
}

var (
	BalanceOfRequestSignature = []byte{0x70, 0xa0, 0x82, 0x31, 0xb9, 0x8e, 0xf4, 0xca, 0x26, 0x8c, 0x9c, 0xc3, 0xf6, 0xb4, 0x59, 0xe, 0x4b, 0xfe, 0xc2, 0x82, 0x80, 0xdb, 0x6, 0xbb, 0x5d, 0x45, 0xe6, 0x89, 0xf2, 0xa3, 0x60, 0xbe}
	BalanceOfResponseSchema   = schema.Parse("(uint256)")
)

func CallBalanceOf(c *jrpc.Client, contract [20]byte, req BalanceOfRequest) (BalanceOfResponse, error) {
	var (
		s4 = BalanceOfRequestSignature[:4]
		cd = append(s4, abi.Encode(req.Encode())...)
	)
	respData, err := c.EthCall(contract, cd)
	if err != nil {
		return BalanceOfResponse{}, err
	}
	respItem, _, err := abi.Decode(respData, BalanceOfResponseSchema)
	defer respItem.Done()
	if err != nil {
		return BalanceOfResponse{}, err
	}
	return DecodeBalanceOfResponse(respItem), nil
}

type DepositToRequest struct {
	item    *abi.Item
	Account [20]byte
}

func (x DepositToRequest) Done() {
	x.item.Done()
}

func DecodeDepositToRequest(item *abi.Item) DepositToRequest {
	x := DepositToRequest{}
	x.item = item
	x.Account = item.At(0).Address()
	return x
}

func (x DepositToRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Address(x.Account)
	return abi.Tuple(items...)
}

var (
	DepositToRequestSignature = []byte{0xb7, 0x60, 0xfa, 0xf9, 0xaf, 0x37, 0xda, 0x13, 0xe9, 0xad, 0x20, 0x38, 0x10, 0xb6, 0x25, 0x2d, 0xd7, 0x27, 0x15, 0x43, 0x5b, 0x4a, 0x87, 0x1, 0x54, 0xce, 0x2f, 0x10, 0xc7, 0xff, 0xf6, 0x72}
	DepositToResponseSchema   = schema.Parse("()")
)

type GetDepositInfoRequest struct {
	item    *abi.Item
	Account [20]byte
}

func (x GetDepositInfoRequest) Done() {
	x.item.Done()
}

func DecodeGetDepositInfoRequest(item *abi.Item) GetDepositInfoRequest {
	x := GetDepositInfoRequest{}
	x.item = item
	x.Account = item.At(0).Address()
	return x
}

func (x GetDepositInfoRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Address(x.Account)
	return abi.Tuple(items...)
}

type GetDepositInfoResponse struct {
	item *abi.Item
	Info GetDepositInfoResponseInfo
}

func (x GetDepositInfoResponse) Done() {
	x.item.Done()
}

func DecodeGetDepositInfoResponse(item *abi.Item) GetDepositInfoResponse {
	x := GetDepositInfoResponse{}
	x.item = item
	x.Info = DecodeGetDepositInfoResponseInfo(item.At(0))
	return x
}

func (x GetDepositInfoResponse) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = x.Info.Encode()
	return abi.Tuple(items...)
}

type GetDepositInfoResponseInfo struct {
	item            *abi.Item
	Deposit         *big.Int
	Staked          bool
	Stake           *big.Int
	UnstakeDelaySec uint32
	WithdrawTime    uint64
}

func (x GetDepositInfoResponseInfo) Done() {
	x.item.Done()
}

func DecodeGetDepositInfoResponseInfo(item *abi.Item) GetDepositInfoResponseInfo {
	x := GetDepositInfoResponseInfo{}
	x.item = item
	x.Deposit = item.At(0).BigInt()
	x.Staked = item.At(1).Bool()
	x.Stake = item.At(2).BigInt()
	x.UnstakeDelaySec = item.At(3).Uint32()
	x.WithdrawTime = item.At(4).Uint64()
	return x
}

func (x GetDepositInfoResponseInfo) Encode() *abi.Item {
	items := make([]*abi.Item, 5)
	items[0] = abi.BigInt(x.Deposit)
	items[1] = abi.Bool(x.Staked)
	items[2] = abi.BigInt(x.Stake)
	items[3] = abi.Uint32(x.UnstakeDelaySec)
	items[4] = abi.Uint64(x.WithdrawTime)
	return abi.Tuple(items...)
}

var (
	GetDepositInfoRequestSignature = []byte{0x52, 0x87, 0xce, 0x12, 0xfb, 0x32, 0xcd, 0xc7, 0x17, 0x16, 0xc6, 0xf4, 0xe9, 0x0, 0xb0, 0x86, 0x7a, 0x4f, 0x5d, 0xc8, 0x71, 0x14, 0xca, 0x25, 0xfa, 0xb4, 0x62, 0x9b, 0x1f, 0x21, 0x4d, 0x56}
	GetDepositInfoResponseSchema   = schema.Parse("((uint112,bool,uint112,uint32,uint48))")
)

func CallGetDepositInfo(c *jrpc.Client, contract [20]byte, req GetDepositInfoRequest) (GetDepositInfoResponse, error) {
	var (
		s4 = GetDepositInfoRequestSignature[:4]
		cd = append(s4, abi.Encode(req.Encode())...)
	)
	respData, err := c.EthCall(contract, cd)
	if err != nil {
		return GetDepositInfoResponse{}, err
	}
	respItem, _, err := abi.Decode(respData, GetDepositInfoResponseSchema)
	defer respItem.Done()
	if err != nil {
		return GetDepositInfoResponse{}, err
	}
	return DecodeGetDepositInfoResponse(respItem), nil
}

type GetNonceRequest struct {
	item   *abi.Item
	Sender [20]byte
	Key    *big.Int
}

func (x GetNonceRequest) Done() {
	x.item.Done()
}

func DecodeGetNonceRequest(item *abi.Item) GetNonceRequest {
	x := GetNonceRequest{}
	x.item = item
	x.Sender = item.At(0).Address()
	x.Key = item.At(1).BigInt()
	return x
}

func (x GetNonceRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	items[0] = abi.Address(x.Sender)
	items[1] = abi.BigInt(x.Key)
	return abi.Tuple(items...)
}

type GetNonceResponse struct {
	item  *abi.Item
	Nonce *big.Int
}

func (x GetNonceResponse) Done() {
	x.item.Done()
}

func DecodeGetNonceResponse(item *abi.Item) GetNonceResponse {
	x := GetNonceResponse{}
	x.item = item
	x.Nonce = item.At(0).BigInt()
	return x
}

func (x GetNonceResponse) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.BigInt(x.Nonce)
	return abi.Tuple(items...)
}

var (
	GetNonceRequestSignature = []byte{0x35, 0x56, 0x7e, 0x1a, 0x6f, 0x34, 0x77, 0xc1, 0xb5, 0x64, 0x92, 0xc9, 0xfa, 0xec, 0xb7, 0xbc, 0x25, 0xde, 0x98, 0x14, 0x58, 0x6, 0xaf, 0x28, 0xd1, 0x2a, 0xeb, 0x4, 0xa4, 0xd4, 0x18, 0xf2}
	GetNonceResponseSchema   = schema.Parse("(uint256)")
)

func CallGetNonce(c *jrpc.Client, contract [20]byte, req GetNonceRequest) (GetNonceResponse, error) {
	var (
		s4 = GetNonceRequestSignature[:4]
		cd = append(s4, abi.Encode(req.Encode())...)
	)
	respData, err := c.EthCall(contract, cd)
	if err != nil {
		return GetNonceResponse{}, err
	}
	respItem, _, err := abi.Decode(respData, GetNonceResponseSchema)
	defer respItem.Done()
	if err != nil {
		return GetNonceResponse{}, err
	}
	return DecodeGetNonceResponse(respItem), nil
}

type GetSenderAddressRequest struct {
	item     *abi.Item
	InitCode []byte
}

func (x GetSenderAddressRequest) Done() {
	x.item.Done()
}

func DecodeGetSenderAddressRequest(item *abi.Item) GetSenderAddressRequest {
	x := GetSenderAddressRequest{}
	x.item = item
	x.InitCode = item.At(0).Bytes()
	return x
}

func (x GetSenderAddressRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Bytes(x.InitCode)
	return abi.Tuple(items...)
}

var (
	GetSenderAddressRequestSignature = []byte{0x9b, 0x24, 0x9f, 0x69, 0x1, 0x29, 0x8c, 0x30, 0x8, 0x1e, 0x8d, 0xf0, 0x34, 0xfd, 0xb6, 0x4d, 0x6c, 0x0, 0x72, 0x36, 0x9d, 0x86, 0x30, 0xa7, 0xc4, 0xbc, 0x39, 0x53, 0xbd, 0x84, 0x6e, 0xb2}
	GetSenderAddressResponseSchema   = schema.Parse("()")
)

type GetUserOpHashRequest struct {
	item   *abi.Item
	UserOp GetUserOpHashRequestUserOp
}

func (x GetUserOpHashRequest) Done() {
	x.item.Done()
}

func DecodeGetUserOpHashRequest(item *abi.Item) GetUserOpHashRequest {
	x := GetUserOpHashRequest{}
	x.item = item
	x.UserOp = DecodeGetUserOpHashRequestUserOp(item.At(0))
	return x
}

func (x GetUserOpHashRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = x.UserOp.Encode()
	return abi.Tuple(items...)
}

type GetUserOpHashRequestUserOp struct {
	item                 *abi.Item
	Sender               [20]byte
	Nonce                *big.Int
	InitCode             []byte
	CallData             []byte
	CallGasLimit         *big.Int
	VerificationGasLimit *big.Int
	PreVerificationGas   *big.Int
	MaxFeePerGas         *big.Int
	MaxPriorityFeePerGas *big.Int
	PaymasterAndData     []byte
	Signature            []byte
}

func (x GetUserOpHashRequestUserOp) Done() {
	x.item.Done()
}

func DecodeGetUserOpHashRequestUserOp(item *abi.Item) GetUserOpHashRequestUserOp {
	x := GetUserOpHashRequestUserOp{}
	x.item = item
	x.Sender = item.At(0).Address()
	x.Nonce = item.At(1).BigInt()
	x.InitCode = item.At(2).Bytes()
	x.CallData = item.At(3).Bytes()
	x.CallGasLimit = item.At(4).BigInt()
	x.VerificationGasLimit = item.At(5).BigInt()
	x.PreVerificationGas = item.At(6).BigInt()
	x.MaxFeePerGas = item.At(7).BigInt()
	x.MaxPriorityFeePerGas = item.At(8).BigInt()
	x.PaymasterAndData = item.At(9).Bytes()
	x.Signature = item.At(10).Bytes()
	return x
}

func (x GetUserOpHashRequestUserOp) Encode() *abi.Item {
	items := make([]*abi.Item, 11)
	items[0] = abi.Address(x.Sender)
	items[1] = abi.BigInt(x.Nonce)
	items[2] = abi.Bytes(x.InitCode)
	items[3] = abi.Bytes(x.CallData)
	items[4] = abi.BigInt(x.CallGasLimit)
	items[5] = abi.BigInt(x.VerificationGasLimit)
	items[6] = abi.BigInt(x.PreVerificationGas)
	items[7] = abi.BigInt(x.MaxFeePerGas)
	items[8] = abi.BigInt(x.MaxPriorityFeePerGas)
	items[9] = abi.Bytes(x.PaymasterAndData)
	items[10] = abi.Bytes(x.Signature)
	return abi.Tuple(items...)
}

type GetUserOpHashResponse struct {
	item          *abi.Item
	GetUserOpHash [32]byte
}

func (x GetUserOpHashResponse) Done() {
	x.item.Done()
}

func DecodeGetUserOpHashResponse(item *abi.Item) GetUserOpHashResponse {
	x := GetUserOpHashResponse{}
	x.item = item
	x.GetUserOpHash = item.At(0).Bytes32()
	return x
}

func (x GetUserOpHashResponse) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Bytes32(x.GetUserOpHash)
	return abi.Tuple(items...)
}

var (
	GetUserOpHashRequestSignature = []byte{0xa6, 0x19, 0x35, 0x31, 0x28, 0xdb, 0x14, 0x88, 0x0, 0xa9, 0x62, 0x21, 0x4a, 0x13, 0xa1, 0xe8, 0xbc, 0xb9, 0x39, 0xcf, 0x32, 0x98, 0xc0, 0x7b, 0x55, 0x1, 0x94, 0xe3, 0x72, 0xd2, 0x73, 0xd9}
	GetUserOpHashResponseSchema   = schema.Parse("(bytes32)")
)

func CallGetUserOpHash(c *jrpc.Client, contract [20]byte, req GetUserOpHashRequest) (GetUserOpHashResponse, error) {
	var (
		s4 = GetUserOpHashRequestSignature[:4]
		cd = append(s4, abi.Encode(req.Encode())...)
	)
	respData, err := c.EthCall(contract, cd)
	if err != nil {
		return GetUserOpHashResponse{}, err
	}
	respItem, _, err := abi.Decode(respData, GetUserOpHashResponseSchema)
	defer respItem.Done()
	if err != nil {
		return GetUserOpHashResponse{}, err
	}
	return DecodeGetUserOpHashResponse(respItem), nil
}

type HandleAggregatedOpsRequest struct {
	item             *abi.Item
	OpsPerAggregator []HandleAggregatedOpsRequestOpsPerAggregator
	Beneficiary      [20]byte
}

func (x HandleAggregatedOpsRequest) Done() {
	x.item.Done()
}

func DecodeHandleAggregatedOpsRequest(item *abi.Item) HandleAggregatedOpsRequest {
	x := HandleAggregatedOpsRequest{}
	x.item = item
	var (
		opsPerAggregatorItem0 = item.At(0)
		opsPerAggregator0     = make([]HandleAggregatedOpsRequestOpsPerAggregator, opsPerAggregatorItem0.Len())
	)
	for i0 := 0; i0 < opsPerAggregatorItem0.Len(); i0++ {
		opsPerAggregator0[i0] = DecodeHandleAggregatedOpsRequestOpsPerAggregator(opsPerAggregatorItem0.At(i0))
	}
	x.OpsPerAggregator = opsPerAggregator0
	x.Beneficiary = item.At(1).Address()
	return x
}

func (x HandleAggregatedOpsRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	var (
		opsPerAggregator0      = x.OpsPerAggregator
		opsPerAggregatorItems0 = make([]*abi.Item, len(opsPerAggregator0))
	)
	for i0 := 0; i0 < len(opsPerAggregator0); i0++ {
		opsPerAggregatorItems0[i0] = opsPerAggregator0[i0].Encode()
	}
	items[0] = abi.Array(opsPerAggregatorItems0...)
	items[1] = abi.Address(x.Beneficiary)
	return abi.Tuple(items...)
}

type HandleAggregatedOpsRequestOpsPerAggregator struct {
	item       *abi.Item
	UserOps    []HandleAggregatedOpsRequestOpsPerAggregatorUserOps
	Aggregator [20]byte
	Signature  []byte
}

func (x HandleAggregatedOpsRequestOpsPerAggregator) Done() {
	x.item.Done()
}

func DecodeHandleAggregatedOpsRequestOpsPerAggregator(item *abi.Item) HandleAggregatedOpsRequestOpsPerAggregator {
	x := HandleAggregatedOpsRequestOpsPerAggregator{}
	x.item = item
	var (
		userOpsItem0 = item.At(0)
		userOps0     = make([]HandleAggregatedOpsRequestOpsPerAggregatorUserOps, userOpsItem0.Len())
	)
	for i0 := 0; i0 < userOpsItem0.Len(); i0++ {
		userOps0[i0] = DecodeHandleAggregatedOpsRequestOpsPerAggregatorUserOps(userOpsItem0.At(i0))
	}
	x.UserOps = userOps0
	x.Aggregator = item.At(1).Address()
	x.Signature = item.At(2).Bytes()
	return x
}

func (x HandleAggregatedOpsRequestOpsPerAggregator) Encode() *abi.Item {
	items := make([]*abi.Item, 3)
	var (
		userOps0      = x.UserOps
		userOpsItems0 = make([]*abi.Item, len(userOps0))
	)
	for i0 := 0; i0 < len(userOps0); i0++ {
		userOpsItems0[i0] = userOps0[i0].Encode()
	}
	items[0] = abi.Array(userOpsItems0...)
	items[1] = abi.Address(x.Aggregator)
	items[2] = abi.Bytes(x.Signature)
	return abi.Tuple(items...)
}

type HandleAggregatedOpsRequestOpsPerAggregatorUserOps struct {
	item                 *abi.Item
	Sender               [20]byte
	Nonce                *big.Int
	InitCode             []byte
	CallData             []byte
	CallGasLimit         *big.Int
	VerificationGasLimit *big.Int
	PreVerificationGas   *big.Int
	MaxFeePerGas         *big.Int
	MaxPriorityFeePerGas *big.Int
	PaymasterAndData     []byte
	Signature            []byte
}

func (x HandleAggregatedOpsRequestOpsPerAggregatorUserOps) Done() {
	x.item.Done()
}

func DecodeHandleAggregatedOpsRequestOpsPerAggregatorUserOps(item *abi.Item) HandleAggregatedOpsRequestOpsPerAggregatorUserOps {
	x := HandleAggregatedOpsRequestOpsPerAggregatorUserOps{}
	x.item = item
	x.Sender = item.At(0).Address()
	x.Nonce = item.At(1).BigInt()
	x.InitCode = item.At(2).Bytes()
	x.CallData = item.At(3).Bytes()
	x.CallGasLimit = item.At(4).BigInt()
	x.VerificationGasLimit = item.At(5).BigInt()
	x.PreVerificationGas = item.At(6).BigInt()
	x.MaxFeePerGas = item.At(7).BigInt()
	x.MaxPriorityFeePerGas = item.At(8).BigInt()
	x.PaymasterAndData = item.At(9).Bytes()
	x.Signature = item.At(10).Bytes()
	return x
}

func (x HandleAggregatedOpsRequestOpsPerAggregatorUserOps) Encode() *abi.Item {
	items := make([]*abi.Item, 11)
	items[0] = abi.Address(x.Sender)
	items[1] = abi.BigInt(x.Nonce)
	items[2] = abi.Bytes(x.InitCode)
	items[3] = abi.Bytes(x.CallData)
	items[4] = abi.BigInt(x.CallGasLimit)
	items[5] = abi.BigInt(x.VerificationGasLimit)
	items[6] = abi.BigInt(x.PreVerificationGas)
	items[7] = abi.BigInt(x.MaxFeePerGas)
	items[8] = abi.BigInt(x.MaxPriorityFeePerGas)
	items[9] = abi.Bytes(x.PaymasterAndData)
	items[10] = abi.Bytes(x.Signature)
	return abi.Tuple(items...)
}

var (
	HandleAggregatedOpsRequestSignature = []byte{0x4b, 0x1d, 0x7c, 0xf5, 0x79, 0x1a, 0x8d, 0xc2, 0x94, 0x98, 0xee, 0xd7, 0x89, 0xd7, 0x67, 0x6, 0xfd, 0x81, 0xd6, 0x12, 0x49, 0x2, 0xe6, 0x2e, 0xcd, 0x45, 0xdc, 0x58, 0x40, 0xd8, 0x45, 0xf2}
	HandleAggregatedOpsResponseSchema   = schema.Parse("()")
)

type HandleOpsRequest struct {
	item        *abi.Item
	Ops         []HandleOpsRequestOps
	Beneficiary [20]byte
}

func (x HandleOpsRequest) Done() {
	x.item.Done()
}

func DecodeHandleOpsRequest(item *abi.Item) HandleOpsRequest {
	x := HandleOpsRequest{}
	x.item = item
	var (
		opsItem0 = item.At(0)
		ops0     = make([]HandleOpsRequestOps, opsItem0.Len())
	)
	for i0 := 0; i0 < opsItem0.Len(); i0++ {
		ops0[i0] = DecodeHandleOpsRequestOps(opsItem0.At(i0))
	}
	x.Ops = ops0
	x.Beneficiary = item.At(1).Address()
	return x
}

func (x HandleOpsRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	var (
		ops0      = x.Ops
		opsItems0 = make([]*abi.Item, len(ops0))
	)
	for i0 := 0; i0 < len(ops0); i0++ {
		opsItems0[i0] = ops0[i0].Encode()
	}
	items[0] = abi.Array(opsItems0...)
	items[1] = abi.Address(x.Beneficiary)
	return abi.Tuple(items...)
}

type HandleOpsRequestOps struct {
	item                 *abi.Item
	Sender               [20]byte
	Nonce                *big.Int
	InitCode             []byte
	CallData             []byte
	CallGasLimit         *big.Int
	VerificationGasLimit *big.Int
	PreVerificationGas   *big.Int
	MaxFeePerGas         *big.Int
	MaxPriorityFeePerGas *big.Int
	PaymasterAndData     []byte
	Signature            []byte
}

func (x HandleOpsRequestOps) Done() {
	x.item.Done()
}

func DecodeHandleOpsRequestOps(item *abi.Item) HandleOpsRequestOps {
	x := HandleOpsRequestOps{}
	x.item = item
	x.Sender = item.At(0).Address()
	x.Nonce = item.At(1).BigInt()
	x.InitCode = item.At(2).Bytes()
	x.CallData = item.At(3).Bytes()
	x.CallGasLimit = item.At(4).BigInt()
	x.VerificationGasLimit = item.At(5).BigInt()
	x.PreVerificationGas = item.At(6).BigInt()
	x.MaxFeePerGas = item.At(7).BigInt()
	x.MaxPriorityFeePerGas = item.At(8).BigInt()
	x.PaymasterAndData = item.At(9).Bytes()
	x.Signature = item.At(10).Bytes()
	return x
}

func (x HandleOpsRequestOps) Encode() *abi.Item {
	items := make([]*abi.Item, 11)
	items[0] = abi.Address(x.Sender)
	items[1] = abi.BigInt(x.Nonce)
	items[2] = abi.Bytes(x.InitCode)
	items[3] = abi.Bytes(x.CallData)
	items[4] = abi.BigInt(x.CallGasLimit)
	items[5] = abi.BigInt(x.VerificationGasLimit)
	items[6] = abi.BigInt(x.PreVerificationGas)
	items[7] = abi.BigInt(x.MaxFeePerGas)
	items[8] = abi.BigInt(x.MaxPriorityFeePerGas)
	items[9] = abi.Bytes(x.PaymasterAndData)
	items[10] = abi.Bytes(x.Signature)
	return abi.Tuple(items...)
}

var (
	HandleOpsRequestSignature = []byte{0x1f, 0xad, 0x94, 0x8c, 0xea, 0x9, 0xad, 0xcc, 0xde, 0x2, 0x1a, 0x7c, 0xb8, 0x9a, 0xaf, 0x7a, 0xbc, 0xcd, 0xb6, 0x97, 0x14, 0xd0, 0xc1, 0x71, 0x2f, 0x1d, 0x17, 0xed, 0x8b, 0x0, 0xd7, 0x3e}
	HandleOpsResponseSchema   = schema.Parse("()")
)

type IncrementNonceRequest struct {
	item *abi.Item
	Key  *big.Int
}

func (x IncrementNonceRequest) Done() {
	x.item.Done()
}

func DecodeIncrementNonceRequest(item *abi.Item) IncrementNonceRequest {
	x := IncrementNonceRequest{}
	x.item = item
	x.Key = item.At(0).BigInt()
	return x
}

func (x IncrementNonceRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.BigInt(x.Key)
	return abi.Tuple(items...)
}

var (
	IncrementNonceRequestSignature = []byte{0xb, 0xd2, 0x8e, 0x3b, 0x1c, 0x8b, 0x1b, 0xb6, 0x86, 0xbd, 0xd9, 0xda, 0x5e, 0xd5, 0x36, 0xd2, 0xf1, 0xc4, 0xd5, 0x23, 0xa2, 0xda, 0xa6, 0x89, 0x8b, 0xb6, 0x5c, 0xb8, 0x34, 0xe2, 0x18, 0x46}
	IncrementNonceResponseSchema   = schema.Parse("()")
)

type SimulateHandleOpRequest struct {
	item           *abi.Item
	Op             SimulateHandleOpRequestOp
	Target         [20]byte
	TargetCallData []byte
}

func (x SimulateHandleOpRequest) Done() {
	x.item.Done()
}

func DecodeSimulateHandleOpRequest(item *abi.Item) SimulateHandleOpRequest {
	x := SimulateHandleOpRequest{}
	x.item = item
	x.Op = DecodeSimulateHandleOpRequestOp(item.At(0))
	x.Target = item.At(1).Address()
	x.TargetCallData = item.At(2).Bytes()
	return x
}

func (x SimulateHandleOpRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 3)
	items[0] = x.Op.Encode()
	items[1] = abi.Address(x.Target)
	items[2] = abi.Bytes(x.TargetCallData)
	return abi.Tuple(items...)
}

type SimulateHandleOpRequestOp struct {
	item                 *abi.Item
	Sender               [20]byte
	Nonce                *big.Int
	InitCode             []byte
	CallData             []byte
	CallGasLimit         *big.Int
	VerificationGasLimit *big.Int
	PreVerificationGas   *big.Int
	MaxFeePerGas         *big.Int
	MaxPriorityFeePerGas *big.Int
	PaymasterAndData     []byte
	Signature            []byte
}

func (x SimulateHandleOpRequestOp) Done() {
	x.item.Done()
}

func DecodeSimulateHandleOpRequestOp(item *abi.Item) SimulateHandleOpRequestOp {
	x := SimulateHandleOpRequestOp{}
	x.item = item
	x.Sender = item.At(0).Address()
	x.Nonce = item.At(1).BigInt()
	x.InitCode = item.At(2).Bytes()
	x.CallData = item.At(3).Bytes()
	x.CallGasLimit = item.At(4).BigInt()
	x.VerificationGasLimit = item.At(5).BigInt()
	x.PreVerificationGas = item.At(6).BigInt()
	x.MaxFeePerGas = item.At(7).BigInt()
	x.MaxPriorityFeePerGas = item.At(8).BigInt()
	x.PaymasterAndData = item.At(9).Bytes()
	x.Signature = item.At(10).Bytes()
	return x
}

func (x SimulateHandleOpRequestOp) Encode() *abi.Item {
	items := make([]*abi.Item, 11)
	items[0] = abi.Address(x.Sender)
	items[1] = abi.BigInt(x.Nonce)
	items[2] = abi.Bytes(x.InitCode)
	items[3] = abi.Bytes(x.CallData)
	items[4] = abi.BigInt(x.CallGasLimit)
	items[5] = abi.BigInt(x.VerificationGasLimit)
	items[6] = abi.BigInt(x.PreVerificationGas)
	items[7] = abi.BigInt(x.MaxFeePerGas)
	items[8] = abi.BigInt(x.MaxPriorityFeePerGas)
	items[9] = abi.Bytes(x.PaymasterAndData)
	items[10] = abi.Bytes(x.Signature)
	return abi.Tuple(items...)
}

var (
	SimulateHandleOpRequestSignature = []byte{0xd6, 0x38, 0x3f, 0x94, 0xd3, 0x7c, 0xd0, 0x94, 0xce, 0xb5, 0x3c, 0x4a, 0xea, 0x1a, 0xca, 0x22, 0x7b, 0xe, 0x44, 0xce, 0x62, 0x24, 0x8e, 0xfc, 0xca, 0xf4, 0x15, 0x2a, 0x23, 0xcb, 0x3f, 0xcc}
	SimulateHandleOpResponseSchema   = schema.Parse("()")
)

type SimulateValidationRequest struct {
	item   *abi.Item
	UserOp SimulateValidationRequestUserOp
}

func (x SimulateValidationRequest) Done() {
	x.item.Done()
}

func DecodeSimulateValidationRequest(item *abi.Item) SimulateValidationRequest {
	x := SimulateValidationRequest{}
	x.item = item
	x.UserOp = DecodeSimulateValidationRequestUserOp(item.At(0))
	return x
}

func (x SimulateValidationRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = x.UserOp.Encode()
	return abi.Tuple(items...)
}

type SimulateValidationRequestUserOp struct {
	item                 *abi.Item
	Sender               [20]byte
	Nonce                *big.Int
	InitCode             []byte
	CallData             []byte
	CallGasLimit         *big.Int
	VerificationGasLimit *big.Int
	PreVerificationGas   *big.Int
	MaxFeePerGas         *big.Int
	MaxPriorityFeePerGas *big.Int
	PaymasterAndData     []byte
	Signature            []byte
}

func (x SimulateValidationRequestUserOp) Done() {
	x.item.Done()
}

func DecodeSimulateValidationRequestUserOp(item *abi.Item) SimulateValidationRequestUserOp {
	x := SimulateValidationRequestUserOp{}
	x.item = item
	x.Sender = item.At(0).Address()
	x.Nonce = item.At(1).BigInt()
	x.InitCode = item.At(2).Bytes()
	x.CallData = item.At(3).Bytes()
	x.CallGasLimit = item.At(4).BigInt()
	x.VerificationGasLimit = item.At(5).BigInt()
	x.PreVerificationGas = item.At(6).BigInt()
	x.MaxFeePerGas = item.At(7).BigInt()
	x.MaxPriorityFeePerGas = item.At(8).BigInt()
	x.PaymasterAndData = item.At(9).Bytes()
	x.Signature = item.At(10).Bytes()
	return x
}

func (x SimulateValidationRequestUserOp) Encode() *abi.Item {
	items := make([]*abi.Item, 11)
	items[0] = abi.Address(x.Sender)
	items[1] = abi.BigInt(x.Nonce)
	items[2] = abi.Bytes(x.InitCode)
	items[3] = abi.Bytes(x.CallData)
	items[4] = abi.BigInt(x.CallGasLimit)
	items[5] = abi.BigInt(x.VerificationGasLimit)
	items[6] = abi.BigInt(x.PreVerificationGas)
	items[7] = abi.BigInt(x.MaxFeePerGas)
	items[8] = abi.BigInt(x.MaxPriorityFeePerGas)
	items[9] = abi.Bytes(x.PaymasterAndData)
	items[10] = abi.Bytes(x.Signature)
	return abi.Tuple(items...)
}

var (
	SimulateValidationRequestSignature = []byte{0xee, 0x21, 0x94, 0x23, 0xeb, 0xb2, 0xaf, 0x15, 0xd7, 0xe, 0xb5, 0x1a, 0x93, 0x85, 0x71, 0xc5, 0xc, 0x34, 0xb7, 0x40, 0x50, 0xfc, 0xae, 0x5b, 0xb5, 0xd0, 0x32, 0xd0, 0xa4, 0xdc, 0x58, 0x18}
	SimulateValidationResponseSchema   = schema.Parse("()")
)
var (
	UnlockStakeRequestSignature = []byte{0xbb, 0x9f, 0xe6, 0xbf, 0xda, 0xda, 0xe1, 0x62, 0xb9, 0x30, 0x9c, 0x70, 0x35, 0x6f, 0x41, 0xec, 0xfe, 0x6e, 0x45, 0x3e, 0xc6, 0x89, 0xab, 0xac, 0x37, 0xfe, 0xf, 0x46, 0x8b, 0xd9, 0xb1, 0x41}
	UnlockStakeResponseSchema   = schema.Parse("()")
)

type WithdrawStakeRequest struct {
	item            *abi.Item
	WithdrawAddress [20]byte
}

func (x WithdrawStakeRequest) Done() {
	x.item.Done()
}

func DecodeWithdrawStakeRequest(item *abi.Item) WithdrawStakeRequest {
	x := WithdrawStakeRequest{}
	x.item = item
	x.WithdrawAddress = item.At(0).Address()
	return x
}

func (x WithdrawStakeRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 1)
	items[0] = abi.Address(x.WithdrawAddress)
	return abi.Tuple(items...)
}

var (
	WithdrawStakeRequestSignature = []byte{0xc2, 0x3a, 0x5c, 0xea, 0x22, 0xb3, 0xd0, 0x9a, 0xfa, 0x94, 0x97, 0x60, 0x89, 0x8, 0xc1, 0xf3, 0xe8, 0x3, 0xd4, 0x74, 0x1a, 0xe1, 0xd9, 0xab, 0x1e, 0xa7, 0xb2, 0xd1, 0x3a, 0xb1, 0x63, 0x24}
	WithdrawStakeResponseSchema   = schema.Parse("()")
)

type WithdrawToRequest struct {
	item            *abi.Item
	WithdrawAddress [20]byte
	WithdrawAmount  *big.Int
}

func (x WithdrawToRequest) Done() {
	x.item.Done()
}

func DecodeWithdrawToRequest(item *abi.Item) WithdrawToRequest {
	x := WithdrawToRequest{}
	x.item = item
	x.WithdrawAddress = item.At(0).Address()
	x.WithdrawAmount = item.At(1).BigInt()
	return x
}

func (x WithdrawToRequest) Encode() *abi.Item {
	items := make([]*abi.Item, 2)
	items[0] = abi.Address(x.WithdrawAddress)
	items[1] = abi.BigInt(x.WithdrawAmount)
	return abi.Tuple(items...)
}

var (
	WithdrawToRequestSignature = []byte{0x20, 0x5c, 0x28, 0x78, 0xe2, 0xb9, 0x71, 0x8d, 0x4e, 0xfa, 0x33, 0x68, 0x21, 0xca, 0x46, 0x8d, 0x10, 0x6, 0x91, 0x99, 0x37, 0x25, 0x64, 0x2f, 0xed, 0xa8, 0x73, 0xd8, 0x6f, 0xf0, 0x24, 0x69}
	WithdrawToResponseSchema   = schema.Parse("()")
)
